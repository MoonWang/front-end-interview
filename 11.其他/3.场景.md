# 1、聊天室项目，如果数据传错了怎么办？

- 如何校验传错了
    - 
- 如何解决传错了
    - 重复指定数据？

# 2、无线滚动列表（头条的新闻列表，看的的多了，列表越来越大，如何处理）

业内虽然有现成的解决方案固然是好事，但是每种方案都有自己的特性，并不一定都合适，以react-virtualized来说，它的特性在pc上算是一个很有趣也很不错的解决方案了：

　　1、它构造一个“足够大”的容器来再现滚动条的实际数值；
　　2、它使用绝对定位来不断跟随滚动事件，改变元素的位置，几乎完美还原了正常列表的视觉，而且无论dom再多也不会卡顿；

不过，与此同时，它也有一些不足：

　　1、因为使用了scroll事件，某种程度上，就注定了在ios上的不足（ios scroll时会阻塞js执行），加上它的缓冲区其实是单向的（虽然这也体现了作者想尽可能节省dom的愿景），导致用户如果上下来回滚动，则很容易看到白屏；
　　2、由于绝对定位的“小技巧”，它要求在组件渲染之初就必须知道每一行元素的高度，但是这个看起来不起眼的小操作，却很大的影响了开发的体验（很不凑巧的笔者使用的无限列表的场景，很多情况下列表元素的高度都不能预先知道。。）

也基于以上原因，虽然react-virtualized是很不错的解决方案了，但是笔者最终没有采用。不过，在广泛借鉴了各大厂的实现之后，笔者发现，手淘列表页的实现，最简单也最有效，那么简单说下实现思路：

　　1、它引入了分页的概念，在用户不断刷新增加页面长度的同时，它将若干元素分为一页；
　　2、然后在滚动的时候计算当前滚动到了具体的哪一页，将“多余”（不需要显示，也不需要作为缓冲显示）的页的高度取出，直接赋值在容器上，然后将容器内所有元素置空；
　　3、当“当前页”发生变化时，动态将需要显示“空页”重新加上元素。

其实这一解决方案也有反复操作dom的性能问题，而且它并不是dom数量优化上的最优解，但是结合笔者的实际使用场景，而且结合考虑到对业务同学的api友好等各方面的，笔者最终也选择了这一实现，虽然各方面性能不是最好，但是在笔者当前的使用场景中，却最是有效的。

简单的小结一下，其实有关无限列表的实现有很多种方案，使用原生scroll事件的痛点在于ios的js阻塞问题以及如何巧妙的设计缓冲区，而使用transform模拟滚动的痛点则是有具体场景的限制和整体的重构成本，两种方案各有千秋，具体使用还需要看具体的使用场景，所以，聪明的你，告诉我？我们需要无线滚动列表么？

# 3、如果有这样一个业务场景，一个模块A作为输入，BCD…等扩展模块可以在A做更改后展示A的原来内容或者加上CSS后的内容，想想思路 

- 不用从DOM层面讲，我想听听广播方法和数据流控制
- 可以不用类Vue Object的原生方法实现这个双向数据绑定吗
    - 可以按照发布订阅来实现的

改改问题
## 你这个方法锁定了A作为输入源，如果A也可以作为输出模块呢，就是说再来了一个V模块，他做输入，ABC…模块变化输出，你增么扩展这个功能 

- 在trigger函数触发的时候，设置一个target，调用每一个扩展模块的callback的时候，传递target给输出模块，统一管理
真的是运气好…

# 4、同一个网站，在上海打开慢，在北京打开快，怎么分析原因（DNS解析、CDN）

# 5、两台电脑之间同步画板如何是实现 

# 6、给一个 ul 列表，找到点击的 li 对象，把点击的对象的字符串翻转

