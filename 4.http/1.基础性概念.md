
# 1、发送和接收中各层的数据封装

## 发送方从高层到低层封装数据

1. 应用层：把各式各样的数据如字母、数字、汉字、图片等转换成二进制，**数据**
2. 传输层：分割上层数据成小数据段，并为每个分段后的数据封装 TCP 报文头部（关键端口号），组合成**数据段**
    - 端口号用于标识上层的协议或应用程序，确保上层数据的正常通信
    - 计算机可以多进程并发运行，如发邮件的同时可以通过浏览器浏览网页，这两种应用通过端口号进行区分
3. 网络层：给数据段加上 IP 报文头部（关键 IP 地址），组合成**数据包**
    - IP 地址用于标识网络的逻辑地址
4. 数据链路径层：给数据包加上 MAC 头部（关键 MAC 地址）和尾部，组成**数据帧**
    - MAC 地址就是固化在硬件设备内部的全球唯一的物理地址
5. 物理层：将上面层层封装后的二进制数据**比特流转换成电信号**在网络中传输

## 接收方从低层到高层解封数据

1. 物理层：先把电信号转成二进制数据，并将数据传送至数据链路层
2. 数据链路层：把 MAC 头部拆掉，并将剩余的数据传送至网络层
3. 网络层：把 IP 头部拆掉，并将剩余的数据送至传输层
4. 传输层：把 TCP 头部拆掉，将真实的数据传送至应用层
5. 应用层：使用真实数据

# 2、TCP

> 传输层协议
> 在发送端：为了方便通信，将 HTTP 请求报文分割成报文段，并设置序号，实现可靠发送
> 在接收端：将接受到的报文段重组，按照原来的顺序

- 协议特点：
    - 是**面向连接的、可靠的**进程到进程通信的协议（端口号）
        - 保证双向的接收和发送都正常
        - 并非实际物理连接
        - 靠端口号确认具体进程
    - TCP提供全双工服务，即数据可在同一时间双向传播
    - TCP将若干个字节构成一个分组，此分组称为报文段(Segment)
- 协议功能
    - 将数据进行**分段打包**传输
    - 对每个数据包**编号控制顺序**
    - 运输中丢失、重发和丢弃处理
    - **流量控制**避免拥塞
- 数据段：
    - TCP头部（主要提供端口号）
        - 双方端口号
        - 序列号
        - 确认号
        - 基本信息
        - 校验
    - 数据（应用层提供的具体数据）
- 三次握手（连接）
    1. 主机A SYN ，发出连接请求
    2. 主机B SYN ACK ，响应收到主机 A 连接请求，发出连接请求（确认主机 A -> 主机 B 正常）
    3. 主机A ACK ，响应收到主机 B 连接请求（确认主机 B -> 主机A 正常）
- 四次挥手（断开）
    1. 主机A ACK FIN ，发出断开请求
    2. 主机B ACK ，响应收到主机 A 断开请求
        - 注：如果主机 B 还有还数据未发送，则该响应不能省略，不能等待数据发完后只发送 3 ，因为不立即响应的话，主机 A 会一直发送请求
    3. 主机B ACK FIN ，主机 B 确认可以断开后（等将剩余数据发送完后），发出断开请求
        - 注：如果主机 B 还有还数据未发送，则主机 B 不能立即断开连接，需要确认数据已发送完成才断开，此时不能和 2 合并；如果没有数据了可以直接合并，省略 2
    4. 主机A ACK ，响应收到主机 B 断开请求

# 3、DNS

> 应用层，DNS 服务器进行域名和与之对应的 IP 地址转换的服务器

查找过程：
1. 客户端向 **本地 DNS 服务器** 发出请求，要 www.163.com 的 IP 地址，本地有缓存则直接返回，没有则进入2
2. 本地 DNS 服务器向 **DNS 根服务器** 发出请求，返回 **.com域服务器** 地址
3. 本地 DNS 服务器向 .com域服务器 发出请求，返回 **163.com域服务器** 地址
4. 本地 DNS 服务器向 163.com域服务器 发出请求，返回域名的 IP 地址 1.1.1.1
5. 本地 DNS 服务器向客户端回复域名 www.163.com 对应的 IP 地址是1.1.1.1，并写入到缓存

# 4、HTTP 协议理解、用法

> 应用层协议，通过请求和响应达成通信
> 在发送端：生成针对目标 Web 服务器的 HTTP 请求报文
> 在接收端：对 Web 服务器请求的内容进行处理

## 请求 request

- 请求头
    - method、path、version
- 请求行
    - accept 协商：编码、字符集、语言
    - 缓存：If-None-Match、If-Modified-Since
    - cookie
    - host、ua
- 请求体
    - 内容

## 响应 response

- 响应行
    - status、code、version
    - 状态码
        - 1.x 临时 101
        - 2.x 成功 200 204 206
        - 3.x 资源改变 301 302 304
        - 4.x 客户端错误 400 401 403 404
        - 5.x 服务端错误 500 502 503 504
- 响应头
    - Content实体首部：编码、语言、长度、类型
    - 缓存：Last-Modified、ETag、Cache-Control
- 响应体
    - 具体数据
    - JSON

# 5、不同版本http

> HTTP 性能优化的关键并不在于高带宽，而是低延迟；关注于减少延迟时间，从而提高页面加载速度

- HTTP 1.0 
    - 每一个请求都要建立一个连接
    - 并发限制在 4-6 个，可以考虑影子域名加载静态资源
    - 三次握手无法复用，非常耗时
        - TCP 连接会随着时间进行自我「调谐」，被称为 TCP 慢启动
- HTTP 1.1 
    - 长连接
        - 默认开启 Connection： keep-alive
    - Pipeling 管线化（复用 tcp 链接，同步）
- HTTP 2 
    - 头部压缩
    - 多路复用
    - 服务器推送
    - 新的二进制格式（Binary Format）

# 6、websocket 实现原理

是 HTML5 的协议，跟 HTTP 协议基本没有关系，但是为了兼容现有浏览器的握手规范，需要基于 HTTP 进行连接的创建。

相对于 HTTP 这种非持久的协议来说，Websocket 是一个持久化的协议