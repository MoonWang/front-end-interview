链表排序（冒泡、选择、插入、快排、归并、希尔、堆排序）、动态规划、递归

# 1、说下快排的完整性

## 排序、链表排序

```js
// 两个元素互换方法
function swap(arr, index1, index2){
    var aux = arr[index1];
    arr[index1] = arr[index2];
    arr[index2] = aux;
};
```

### 交换排序：冒泡排序 O(n²)、快速排序 O(n㏒n)

原理：相邻两个相比，根据结果调换二者的位置，每次判断的都是当前最大值（最大值和i没有必然关系）
```js
this.bubbleSort = function(arr){
    var length = arr.length;
    for (var i=0; i<length; i++){
        for (var j=0; j<length-1-i; j++ ){ 
            if (arr[j] > arr[j+1]){
                swap(arr, j, j+1);
            }
        }
    }
    return arr;
};
```

### 选择排序：选择排序 O(n²)、堆排序 O(n㏒n)

原理：从未排序中找到最小值，并放到已排序的最后一位

```js
function selectionSort(arr){
    var length = arr.length,
        indexMin;
    for (var i=0; i<length-1; i++){
        // 假设当前最小
        indexMin = i;
        for (var j=i; j<length; j++){
            if(arr[indexMin]>array[j]){
                indexMin = j;
            }
        }
        if (i !== indexMin){
            swap(arr, i, indexMin);
        } 
    }

    return arr;
};
```

### 插入排序：插入排序 O(n²)、希尔排序 O(n1.3)

原理：遍历数据结构，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

```js
function insertionSort(arr){
    var length = arr.length,
        j, temp;
    for (var i=1; i<length; i++){
        j = i;
        // 先取出来要判断的值
        temp = arr[i];
        while (j>0 && arr[j-1] > temp){
            // 每次不对都会将当前对比值后移（不怕覆盖，后面是个空值，已经被 temp 取走）
            arr[j] = arr[j-1];
            j--; 
        }
        // 直接插回合适的地方，该地方原来的数值已经在上一步被移动到了后一位
        arr[j] = temp;
    }
};
```

核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素(先大排，再小排)

在开始做最后一次处理时，大部分元素都将在正确的位置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方

```js
// 动态计算间隔
function shellsort1(arr) {
    var N = arr.length;
    var h = 1;
    while (h < N/3) {
        h = 3 * h + 1;  // 1 4 13 40 
    }
    while (h >= 1) {
        for (var i = h; i < N; i++) {
            for (var j = i; j >= h && arr[j] < arr[j-h]; j -= h) {
                swap(arr, j, j-h);
            }
        }
        h = (h-1)/3;        // 每次动态获选一个间隔
    }

    return arr;
}
```

### 归并排序：二路归并排序 O(n㏒n)、多路归并排序

分治思路：将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组

说明：是稳定排序，表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

```js
function mergeSort(array){
    var length = array.length;
    if(length === 1) {
        return array;                   // 最终分割为只有1个元素的数组，就可以返回，开始递归向外的合并过程
    }
    var mid = Math.floor(length / 2),
        left = array.slice(0, mid),
        right = array.slice(mid, length);
    return merge(mergeSort(left), mergeSort(right));
};

function merge(left, right){      // 排序是在合并的过程中处理的
    var result = [],
        il = 0,
        ir = 0;
    while(il < left.length && ir < right.length) {
        if(left[il] < right[ir]) {      // 左边小，则把左边的元素添加到结果数组中，且左边的遍历索引++
            result.push(left[il++]);
        } else{                         // 右边小则操作右边
            result.push(right[ir++]);
        } 
    }
    while (il < left.length){           // 上面判断完以后，把剩下的左边的和右边的都添加到结果数组中
         result.push(left[il++]);       // 左和右最多只会生一个没添加完，由于剩下的也是已经排序的，所以可以直接添加到结果数组中
    }   
    while (ir < right.length){
        result.push(right[ir++]);
    }
    console.log(result);                // 可以用这个看一下递归的每层结果，比较直观
    return result;
};
```

堆排序
